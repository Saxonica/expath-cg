<?xml version="1.0" encoding="UTF-8"?><!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<spec xmlns:ex="http://expath.org/ns/xmlspec" role="editors-copy" ex:w3c="true">
  <header>
    <title>Archive Module</title>
    <w3c-designation>w3c-designation</w3c-designation>
    <w3c-doctype>EXPath Candidate Module</w3c-doctype>
    <pubdate>
      <day>12</day>
      <month>May</month>
      <year>2014</year>
    </pubdate>
    <publoc>
      <loc diff="chg" href="http://expath.org/spec/archive/20140512"/>
    </publoc>
    <altlocs>
      <loc diff="chg" href="http://expath.org/spec/archive/20140512.xml">XML</loc>
    </altlocs>
    <latestloc>
      <loc href="http://expath.org/spec/archive"/>
    </latestloc>

    <prevlocs>
      <loc diff="add" href="http://expath.org/spec/archive/20131205"/>
      <loc href="http://expath.org/spec/archive/20130930"/>
      <loc href="http://expath.org/spec/zip/20101012"/>
    </prevlocs>

    <authlist>
      <author role="editor">
        <name>John Lumley</name>
        <affiliation>Saxonica Ltd</affiliation>
        <email href="mailto:john@saxonica.com">john@saxonica.com</email>
      </author>
      <author role="contrib">
        <name>Christian Grün</name>
        <affiliation>BaseX GmbH</affiliation>
        <email href="mailto:christian.gruen@gmail.com">christian.gruen@gmail.com</email>
      </author>
      <author role="contrib">
        <name>Matthias Brantner</name>
        <affiliation>28msec GmbH</affiliation>
        <email href="mailto:matthias.brantner@28msec.com">matthias.brantner@28msec.com</email>
      </author>
      <author role="contrib">
        <name>Florent Georges</name>
        <affiliation>H2O Consulting</affiliation>
      </author>
    </authlist>
    <copyright>
      <p>Copyright © 2014 John Lumley, Christian Grün, Matthias Brantner and Florent Georges,
        published by the <loc href="http://w3.org/community/expath/">EXPath Community Group</loc>
        under the <loc href="https://www.w3.org/community/about/agreements/cla/">W3C Community
          Contributor License Agreement (CLA)</loc>. A human-readable <loc
          href="http://www.w3.org/community/about/agreements/cla-deed/">summary</loc> is
        available.</p>
      <p>This specification was published by the <loc href="http://www.w3.org/community/expath/"
          >EXPath Community Group</loc>. It is not a W3C Standard nor is it on the W3C Standards
        Track. Please note that under the <loc
          href="http://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License
          Agreement (CLA)</loc> there is a limited opt-out and other conditions apply. Learn more
        about <loc href="http://www.w3.org/community/">W3C Community and Business Groups</loc>.</p>
    </copyright>
    <abstract>
      <p>This proposal provides an API for XPath 2.0 and XPath 3.0 to handle archive data (i.e.
        collected and possibly compressed sets of files and directories). It defines extension
        functions to process data from and to such archives files, including creation, determining
        and setting properties, listing and extracting contents and adding and updating entries. It
        has been designed to be compatible with XQuery 1.0 and XSLT 2.0, as well as any other XPath
        2.0 usage. Some additional features for use in XPath 3.0 are also defined.</p>
    </abstract>
    <status>
      <p/>
    </status>
    <langusage>
      <language>en-US</language>
    </langusage>
    <revisiondesc>
      <p>revisiondesc</p>
    </revisiondesc>
  </header>
  <body>
    <div1 id="status">
      <head>Status of this document</head>
      <p>This document is in an interim draft stage. Comments are welcomed at <loc
          href="mailto:public-expath@w3.org">public-expath@w3.org</loc> mailing list (<loc
          href="http://lists.w3.org/Archives/Public/public-expath/">archive</loc>).</p>
    </div1>
    <div1 id="introduction">
      <head>Introduction</head>
      <div2>
        <head>Namespace conventions</head>
        <p>The module defined by this document defines several functions, all contained in the
          namespace <code>http://expath.org/ns/archive</code>. In this document, the
            <code>arch</code> prefix, when used, is bound to this namespace URI.</p>
        <p diff="del">Alternative versions of these functions using the proposed XPath3.0
            <code>map()</code> type (see <specref ref="using.maps"/>) are defined in the namespace
            <code>http://expath.org/ns/archive-map</code>. In this document, the <code>archM</code>
          prefix, when used, is bound to this namespace URI. </p>
        <p>Error codes are defined in the same namespace
          (<code>http://expath.org/ns/archive</code>), and in this document are displayed with the
          same prefix, <code>arch</code>.</p>
        <note>
          <p>This follows the suggestion (in late August 2013) for a coherent naming standard in
            EXPath modules.</p>
        </note>
        <p>Binary file I/O, to read and write complete archives to files, uses facilities defined in
            <bibref ref="expathfile"/>, which defines functions in the namespace
            <code>http://expath.org/ns/file</code>. In this document, the <code>file</code> prefix,
          when used, is bound to this namespace URI.</p>
        <p>Manipulation of binary data itself can employ functions from <bibref ref="expathbinary"
          />, which defines functions in the namespace <code>http://expath.org/ns/binary</code>. In
          this document, the <code>bin</code> prefix, when used, is bound to this namespace URI.</p>
      </div2>
      <div2>
        <head>Error management</head>
        <p>Error conditions are identified by a code (a <code>QName</code>.) When such an error
          condition is reached in the evaluation of an expression, a dynamic error is thrown, with
          the corresponding error code (as if the standard XPath function <code>error()</code> had
          been called.) The namespace of the code follows that of the module within whose processing
          the error occurs, i.e. <code>http://expath.org/ns/archive</code> for errors in archive
          manipulation, <code>http://expath.org/ns/file</code> for errors in file operations and
            <code>http://expath.org/ns/binary</code> for errors in processing binary data.</p>
      </div2>
      <div2 id="type">
        <head>Archive representation</head>
        <p>Archives in this module are represented principally as items of type
            <code>xs:base64Binary</code>, i.e. in their basic binary (byte sequence) forms.</p>
        <p>Archives are treated as being arranged structurally as a description of overall options
          of the archive and a sequence of named entries. Each entry has:</p>
        <ulist>
          <item>
            <p>A <kw>name</kw>, which is treated as a sequence of Unicode characters. In many cases
              the solidus character (<code>/</code>) is used to imply the entries being logically
              arranged in positions within a directory tree, but this is not mandatory.</p>
          </item>
          <item>
            <p>A set of <kw>properties</kw>, denoting at least the uncompressed size of the entry,
              archive internal properties for the entry, such as the compression method used on the
              stored data and other indications such as the date of last modification.</p>
          </item>
          <item>
            <p><kw>Data</kw>, treated as (possibly null) binary data.</p>
          </item>
        </ulist>
        <p>It is most common that archives are considered to be arranged logically as directories,
          using the entry names to denote paths and file names (e.g.
            <code>tests/qt3/archive/main.xml</code>) In such circumstances, archives may contain
          entries to represent the directories themselves (e.g. <code>tests/qt3/archive/</code>)
          presumably with no data. [This could be used such that full extraction of an archive to a
          file system generates empty output directories for example.] This specification makes no
          distinction between these two cases – if an archive has an empty 'directory' entry it will
          be treated similarly to any other 'file' entry. <emph>Semantic intrepretation of entry
            names as files in directory trees is an application issue.</emph></p>
        <note>
          <p>Behaviour when entries with duplicate names are detected in an archive is
            implementation dependent. Nevertheless, if an error is not thrown, only <emph>one</emph>
            entry should be returned when reading. Implementations <rfc2119>must not</rfc2119> write
            duplicate entries in result archives.</p>
        </note>
      </div2>
      <div2 id="archive.types">
        <head>Archive types</head>
        <p>The module is designed to be able to support a number of different types of archive,
          providing a coherent access mechanism.</p>
        <p>The following archive types are required to be supported:</p>
        <ulist>
          <item>
            <p><bibref ref="zip"/>: (which also covers derivative archive formats, such as JAR or
              OpenDocument.)</p>
          </item>
          <item>
            <p><bibref ref="gzip"/> : A compressed archive of a sequence of files</p>
            <note>
              <p>Within GZIP names of entries (original file names) are optional, on a per-file
                basis, so special measures may need to be taken to handle 'unnamed' sections.</p>
            </note>
          </item>
        </ulist>
        <p>Specific issues arise from i) archives used in streaming situations, where the internal
          manifests of the archives cannot be completed until all data is written, ii) archives
          where the order of entries is important, such as JAR, where the mainfest entries need to
          be first.</p>
        <note>
          <p>Currently there are no proposals within this module to cover encrypted archives.</p>
        </note>
      </div2>
      <div2 diff="add">
        <head>Optional interfaces</head>
        <p>This module defines two distinctly different interface schemes for reporting on and
          manipulating archive data. The first uses XML-structured trees to describe entries, their
          names and their properties, leaving (binary) data described in separate arguments to or
          results from the functions defined. All conformant implementations must support this
          interface.</p>
        <p>An alternative interface, using the proposed XPath3.0 <code>map()</code> type (see
            <specref ref="maps"/>), may be supported by an implementation. This significantly
          increases the coherence of the connection between entries and their data (as binary data
          can be the 'value' of a map entry), at the minor cost of having to specify entry order for
          those archive usages which are order sensitive (e.g. EPUB). This map interface can
          co-exist with the XML-structured one.</p>
      </div2>

    </div1>
    <div1 id="use-cases">
      <head>Use cases</head>
      <p>Development of this specification was driven by requirements which some XML developers
        regularly encounter in examining or generating data which is presented in archival forms.
        Some typical use cases include:</p>
      <ulist>
        <item>
          <p>Manipulating EPUB documents.</p>
        </item>
        <item>
          <p>Examining Java classes and resources stored in <code>JAR</code> formats.</p>
        </item>
      </ulist>
      <div2 id="example.epub">
        <head>Creating a simple EPUB document</head>
        <p>An <bibref ref="epub"/> document is a collection of content sections, written in XHTML,
          with a metadata descriptor (usually the <code>content.opf</code> file) and a navigation
          description (usually the <code>toc.ncx</code> file), all collected together and
          potentially compressed in a ZIP format. A simple example of creating such a document in
          XQuery is:</p>
        <eg diff="chg" xml:space="preserve">
arch:create(
    (
      "mimetype",
      "META-INF/container.xml",
      "OEBPS/content.opf",
      "OEBPS/Text/title.xhtml",
      "OEBPS/Text/chap01.xhtml",
      "OEBPS/toc.ncx"
    ),
    (
      content:mimetype(),
      content:metainf(),
      content:oebps-content(),
      content:title(),
      content:chapter(),
      content:toc()
    )
  )
</eg>
        <p>The user-supplied XQuery function <code>content:mimetype()</code> returns the appropriate
          mimetype description for the EPUB document as a <phrase diff="add">base64-encoding of
            a</phrase> string ("application/epub+zip"). Each of the other <code>content:*()</code>
          functions generates a serialized form of the appropriate XML structure again in a base64
          encoding, e.g.:</p>
        <eg diff="chg" xml:space="preserve">
declare function content:title() as xs:base64Binary
{
  bin:encode-string(fn:serialize(
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;head&gt;
      &lt;title&gt;Title Page&lt;/title&gt;
    &lt;/head&gt;
    
    &lt;body&gt;
      &lt;div&gt;
        &lt;h2 id="heading_id_2"&gt;Sample Book&lt;/h2&gt;
    
        &lt;h2 id="heading_id_3"&gt;A Sample .epub Book&lt;/h2&gt;
    
        &lt;h3 id="heading_id_4"&gt;Title Page&lt;/h3&gt;
      &lt;/div&gt;
    &lt;/body&gt;
    &lt;/html&gt;
  )))
};
</eg>
        <p><phrase diff="del">Using a map struture to define an entry enables properties such as
            compression to be altered on on entry-by-entry basis. </phrase>For and EPUB document the
          mimetype entry <emph>must</emph> be uncompressed (so effectively it can be read by simple
          string searching), but other entries may be compressed.</p>
      </div2>
      <div2 id="example.jar">
        <head>Examining a JAR file</head>
        <p>JAR files contain class code and definitions for Java classes, in entries whose names are
              <emph><code>path/classname</code></emph><code>.class</code>. Local classes (classes
          defined within a class) have separate code entries with a classname
              <emph><code>outerclass</code></emph><code>$</code><emph><code>innerclass</code></emph>.
          To find all the main package-qualified classes the following XPath should suffice: </p>
        <eg diff="chg" xml:space="preserve">
for $e in arch:entry-names(file:read-binary("lib/saxon9-sql.jar"))[ends-with(.,'.class') and not(contains(.,'$'))] 
  return replace(replace($e,'\.class$',''),'/','.')
=&gt; 
   "net.sf.saxon.option.sql.SQLClose", 
   "net.sf.saxon.option.sql.SQLColumn", 
   "net.sf.saxon.option.sql.SQLConnect",
   ....,
   "net.sf.saxon.option.sql.SQLUpdate" 
</eg>
      </div2>
      <div2 diff="del" id="example.zip.to">
        <head>Extracting a ZIP archive to a file system</head>
        <p>The following XSLT function will unzip an archive to the current directory, using the
          file writing functions of <bibref ref="expathfile"/>: </p>
        <eg xml:space="preserve">
&lt;xsl:function name="arch:extract-to-files"&gt;
    &lt;xsl:param name="archive" as="xs:base64Binary"/&gt;
    &lt;xsl:variable name="entries" select="arch:entries($archive)"/&gt;
    &lt;xsl:variable name="dirs" select="$entries[ends-with(.,'/')]"/&gt;
    &lt;xsl:variable name="required.dirs"
        select="distinct-values(for $r in ($entries except $dirs) 
                  return replace($r,'/[^/]+$','/'))[ends-with(.,'/')]"/&gt;
    &lt;xsl:sequence
        select="for $d in distinct-values(($required.dirs,$dirs)) 
                return file:create-dir(replace($d,'/$',''))"/&gt;
    &lt;xsl:sequence
        select="for $f in ($entries except $dirs) 
                return file:write-binary($f,arch:extract-binary($archive,$f))"/&gt;
&lt;/xsl:function&gt;
</eg>
        <p>The function will create empty directories described but not filled in the archive.
            <code>file:create-dir()</code> creates necessary intermediate directories, so
            <code>$dirs</code> does not need to be in a sorted order.</p>
      </div2>
      <div2 diff="del" id="example.zip.from">
        <head>Creating a ZIP archive from a file tree</head>
        <p>The following XSLT function will create an archive from files and (recursive) directories
          named relative to the current directory, using the file reading functions of <bibref
            ref="expathfile"/>: </p>
        <eg xml:space="preserve">
&lt;xsl:function name="arch:from-files" as="xs:base64Binary"&gt;
    &lt;xsl:param name="files" as="xs:string*"/&gt;
    &lt;xsl:variable name="all" as="xs:string*"
      select="for $f in $files return if(file:is-dir($f)) then (for $f1 in file:list($f,true()) return concat($f,$f1)) else $f"/&gt;
    &lt;xsl:variable name="normalized.names" select="for $n in $all return replace($n,'\\','/')"/&gt;
    &lt;xsl:variable name="content" as="xs:base64Binary*"
      select="for $f in $normalized.names return if(file:is-dir($f)) then xs:base64Binary('') else file:read-binary($f)"/&gt;
    &lt;xsl:sequence select="arch:create($normalized.names,$content)"/&gt;
&lt;/xsl:function&gt;
</eg>

      </div2>
    </div1>
    <div1 id="descriptions">
      <head>Describing archives and entries</head>
      <p>The properties of overall archives and individual entries at the XDM level are described by
        small structured elements, with optional information attached. <emph diff="del">In this
          proposal this information is attached as attributes.</emph><emph diff="add">In common with
          description of serialization parameters, these i) use child elements as the property key
          and ii) place scalar values as the <code>@value</code> attribute of that child.</emph></p>
      <note diff="del">
        <p>Parallels with XPath 3.0 serialization parameters, which are now sets of (element) nodes,
          become awkward. In <code>arch:entry</code> we would need to add an element
            <code>arch:name</code> to hold the name of an entry, rather than rely on the string
          value. The major point in favour of using elements rather than attributes would be where
          we need to read or set complex structured parameters, such as character maps. This needs
          discussion.</p>
      </note>
      <div2 id="archive.properties">
        <head>Archive properties and options</head>
        <p>Archive options and properties are described as a structured element
            (<code>element(arch:options)</code>) with the following <phrase diff="del"
            >attributes</phrase><phrase diff="add">child elements, all of whose values are described
            in their <code>@value</code> attribute</phrase>:</p>
        <ulist>
          <item>
            <p><kw diff="chg">arch:format</kw>: the type of the archive, e.g. "zip". This is
              mandatory.</p>
          </item>
          <item>
            <p><kw diff="chg">arch:algorithm</kw>: the default compression used in the archive, e.g.
              "deflate".</p>
          </item>
        </ulist>
        <p>Other attributes may be dependent upon the type of the archive and the
          implementation.</p>
      </div2>
      <div2 id="entry.structures">
        <head>Entry descriptions</head>
        <p>Entries within the archive can be accessed by name (<code>xs:string</code>) or a
          structured element (<code>element(arch:entry)</code>). In the latter case the entry name
          is the <phrase diff="del">string</phrase>
          <phrase diff="add">value of the <code>@value</code> attribute of the
              <code>arch:name</code> child.</phrase></p>
        <p>When describing an existing entry in an archive, <code>element(arch:entry)</code> may be
          returned with the following (optional) <phrase diff="del">attributes</phrase>
          <phrase diff="add">children, all of whose values are described in the <code>@value</code>
            attribute</phrase>:</p>
        <ulist>
          <item diff="add">
            <p><kw>arch:name</kw>: the (path) name of the entry. <rfc2119>REQUIRED</rfc2119></p>
          </item>
          <item>
            <p><kw diff="chg">arch:size</kw>: the original file size of the entry.</p>
          </item>
          <item>
            <p><kw diff="chg">arch:compressed-size</kw>: the compressed file size of the entry, i.e.
              the number of bytes it occupies in the archive.</p>
          </item>
          <item>
            <p><kw diff="chg">arch:last-modified</kw>: the date of last modification of this entry,
              in <code>xs:dateTime</code> notation.</p>
          </item>
          <item>
            <p><kw diff="chg">arch:compression-level</kw>: an indicator of the level of (lossless?)
              compression.</p>
          </item>
        </ulist>
        <p>When used to create or update an entry in an archive, <code>element(arch:entry)</code>
          may also have the following (optional) <phrase diff="del">attributes</phrase>
          <phrase diff="add">children</phrase>:</p>
        <ulist>
          <item diff="add">
            <p><kw>arch:name</kw>: the (path) name of the entry. <rfc2119>REQUIRED</rfc2119></p>
          </item>
          <item>
            <p><kw diff="chg">arch:last-modified</kw>: the date of last modification to be written
              on this entry, in <code>xs:dateTime</code> notation.</p>
          </item>
          <item>
            <p><kw diff="chg">arch:compression-level</kw>: the level of (lossless?) compression to
              be used in writing the entry into the archive.</p>
          </item>
          <item>
            <p><kw diff="chg">arch:encoding</kw>: the encoding to be used for converting textual
              items to a byte sequence, prior to possible compression and writing to the archive.
                <phrase diff="add">The only values which every implementation is
                  <rfc2119>required</rfc2119> to recognize are <code>utf-8</code> and
                  <code>utf-16</code></phrase></p>
          </item>
        </ulist>
        <p>(In writing actions, unknown <phrase diff="del">attributes</phrase>
          <phrase diff="add">children</phrase> are ignored.<phrase diff="add"> In the case of
            duplicate children, the value of the <emph>first</emph> child is taken.</phrase>)</p>
      </div2>

    </div1>
    <div1 id="loading">
      <head>Loading and saving archives</head>
      <p>This module defines no specific functions for reading and writing archives from files, as
        distinct from their binary data. The EXPath File Module <bibref ref="expathfile"/> provides
        two suitable functions to do this:</p>
      <ulist>
        <item>
          <p>
            <ex:function><a href="http://expath.org/spec/file#d3e954"
              >file:read-binary</a></ex:function>($file as <ex:type>xs:string</ex:type>) as
              <ex:type>xs:base64Binary</ex:type>. Returns the content of a file in its Base64
            representation.</p>
        </item>
        <item>
          <p>
            <ex:function><a href="http://expath.org/spec/file#d3e1359"
              >file:write-binary</a></ex:function>($file as <ex:type>xs:string</ex:type>, $value as
              <ex:type>xs:base64Binary</ex:type>) as <ex:type>empty-sequence()</ex:type>. Writes a
            Base64 item as binary to a file. </p>
        </item>
      </ulist>
      <note>
        <p diff="del">There may be some desire for some convenience functions <code>arch:write($file
            as <ex:type>xs:string</ex:type>,....) as empty-sequence()</code> which does creation and
          file writing as one action.</p>
        <p diff="add">The functions detailed in <specref ref="fn.to.files"/> and <specref
            ref="fn.from.files"/> may be used to transfer between file system directory trees and
          archives in a single operation.</p>
      </note>
    </div1>
    <div1 id="information">
      <head>Information about an archive and its contents</head>
      <div2 id="fn.options">
        <head>arch:options</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns a description of the type and properties of a given archive. </p>
            </def>
          </gitem>
          <gitem>
            <label>Signature</label>
            <def>
              <p><example role="signature">
                  <proto name="options" return-type="element(arch:options)*" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>The description is returned as an element <code>&lt;arch:options&gt;</code> with an
                unordered sequence of child elements describing the details. The following are
                currently supported:</p>
              <ul>
                <li><code>arch:format</code>: format of this archive</li>
                <li><code>arch:algorithm</code>: the compression algorithm that was used.</li>
              </ul>
              <p>If the archive format supports a compression algorithm varying on a per-entry
                basis, and more than one algorithm has been used in the archive, <code>mixed</code>
                is returned for <code>arch:algorithm</code>.</p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.archiveReadError"/> is raised if there is an unspecified problem
                in reading the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Examples</label>
            <def>

              <p>Finding the properties of the archive stored in a file located at
                <code>$uri</code>:</p>
              <eg diff="chg" xml:space="preserve">
arch:options(file:read-binary($uri))
=&gt; &lt;arch:options&gt;
     &lt;arch:format value="ZIP"/&gt;
     &lt;arch:algorithm value="deflate"/&gt;
   &lt;/arch:options&gt;</eg>

            </def>
          </gitem>
        </glist>
      </div2>
      <div2 diff="add" id="fn.entry.names.map">
        <head>arch:entry-names</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns the entry names for all the entries found within the archive as a sequence
                of string values in the order in which they appear in the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signature</label>
            <def>
              <p><example role="signature">
                  <proto name="entry-names" return-type="xs:string*" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Returns the entry names for all the entries found within the archive as a sequence
                of string values in the order in which they appear in the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.archiveReadError"/> is raised if there is an unspecified problem
                in reading the archive.</p>
            </def>
          </gitem>
        </glist>
      </div2>
      <div2 id="fn.entries">
        <head>arch:entries</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns the set of entry descriptors for all the entries found within the archive.
              </p>
            </def>
          </gitem>
          <gitem>
            <label>Signature</label>
            <def>
              <p><example role="signature">
                  <proto name="entries" return-type="element(arch:entry)*" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Each descriptor is an element <code>&lt;arch:entry&gt;</code> whose text value is
                the path of the file within the archive. For more details of this structure see
                  <specref ref="entry.structures"/>.</p>
              <p>The entries are returned in the order in which they encountered serially within the
                archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.archiveReadError"/> is raised if there is an unspecified problem
                in reading the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Notes</label>
            <def>
              <p>There may be a case for providing a sorted version, probably using some form of
                collation.</p>
            </def>
          </gitem>
          <gitem>
            <label>Examples</label>
            <def>

              <p>Finding the entries of the archive stored in a file located at
                <code>$uri</code>:</p>
              <eg diff="chg" xml:space="preserve">
arch:entries(file:read-binary($uri))
=&gt; &lt;arch:entry&gt;
      &lt;arch:name value="lumley.jpg"/&gt;
      &lt;arch:size value="2194"/&gt;
      &lt;arch:compressed-size value="652"/&gt;
      &lt;arch:last-modified value="2013-07-18T11:22:12"/&gt;
   &lt;/arch:entry&gt;
   &lt;arch:entry size="84983" compressed-size="84872" last-modified="2009-03-23T11:15:06"&gt;lumley.jpg&lt;/arch:entry&gt;
   &lt;arch:entry size="10058" compressed-size="1381" last-modified="2013-08-06T13:14:08"&gt;tests/qt3/binary/binary.xml&lt;/arch:entry&gt;
     </eg>
              <p>Summing the size of the apparent XML files in the previous example:</p>
              <eg xml:space="preserve">
sum(arch:entries(file:read-binary($uri))[ends-with(arch:name/@value,'.xml')]arch:size/@value)
=&gt; 10058
     </eg>

            </def>
          </gitem>
        </glist>
      </div2>
    </div1>
    <div1 id="extraction">
      <head>Extracting entries from an archive</head>
      <p>The module does not attempt to discern the 'type' of an entry (such as 'text', 'XML',
        'raw-binary'), leaving that to the programmer. Two forms of reading result are supported:
        raw binary (<code>xs:base64Binary</code>) and decoded text (<code>xs:string</code>). </p>
      <div2 id="fn.extract.binary">
        <head>arch:extract-binary</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns the sequence of requested entries from the archive as binary data.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signature</label>
            <def>
              <p><example role="signature">
                  <proto name="extract-binary" return-type="xs:base64Binary*" isOp="no"
                    prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="xs:string*"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Returns as binary data each entry in the archive <code>$archive</code> that corresponds
                to the entry name input, in sequence.</p>
              <p>The entries <rfc2119>must</rfc2119> be returned in the order corresponding to that
                of the entries requested in <code>$entries</code>, not in the order in which they
                may exist in the archive.</p>
              <p>Multiple requests for the same entry will be honoured, with copies of the entry
                appearing in corresponding multiple locations in the output sequence .</p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.unknownEntry"/> is raised if an entry requested does not exist
                in this archive.</p>
              <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified
                problem in reading the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Notes</label>
            <def>
              <p>There have been suggestions for a signature <code>arch:extract-binary($archive as
                  xs:base64Binary)</code> returning all the entries. In the absence of maps in the
                return type, this does not make sense, since the entries are totally unlabelled, and
                to get anything meaningful, a parallel call on <code>arch:entries()</code> would be
                required.</p>
            </def>
          </gitem>
          <gitem>
            <label>Examples</label>
            <def>

              <p>Returning the binary data for an entry in the archive stored in a file located at
                  <code>$uri</code>:</p>
              <eg xml:space="preserve">
arch:extract-binary(file:read-binary($uri),'build.xml')
=&gt; stuff
     </eg>


            </def>
          </gitem>
        </glist>
      </div2>
      <div2 id="fn.extract.text">
        <head>arch:extract-text</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns the sequence of requested entries from the archive as strings. If
                  <code>$encoding</code> is specified the strings are decoded appropriately,
                otherwise UTF-8 encoding is assumed.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signatures</label>
            <def>
              <p><example role="signature">
                  <proto name="extract-text" return-type="xs:string*" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="xs:string*"/>
                  </proto>
                </example><example role="signature">
                  <proto name="extract-text" return-type="xs:string*" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="xs:string*"/>
                    <arg name="encoding" type="xs:string"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Returns as a string each entry in the archive <code>$archive</code> that corresponds to
                the entry name input, in sequence.</p>
              <p>If <code>$encoding</code> is specified the strings are decoded appropriately,
                otherwise UTF-8 encoding is assumed.</p>
              <p>The entries <rfc2119>must</rfc2119> be returned in the order corresponding to that
                of the entries requested in <code>$entries</code>, not in the order in which they
                may exist in the archive.</p>
              <p>Multiple requests for the same entry will be honoured, with copies of the entry
                appearing in corresponding multiple locations in the output sequence .</p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.unknownEntry"/> is raised if an entry requested does not exist
                in this archive.</p>
              <p><bibref ref="error.unknownEncoding"/> is raised if the encoding requested is
                unknown or unsupported.</p>
              <p><bibref ref="error.decoding"/> is raised if there was an error in decoding the
                entry.</p>
              <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified
                problem in reading the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Notes</label>
            <def>
              <p>This function should be equivalent to the use of <code>arch:extract-binary()</code>
                and the function <code>bin:decode-string()</code> from <bibref ref="expathbinary"
                />:</p>
              <eg>arch:extract-binary($archive,$entries) ! bin:decode-string(.,$encoding) [XPath
                3.0]</eg>
              <eg>for $b in arch:extract-binary($archive,$entries) return bin:decode-string($b,$encoding)
                [XPath 2.0]</eg>
              <p>Further conversion into XML can be achieved using the XPath3.0 function
                  <code>fn:parse-XML()</code> on each of the returned strings.</p>
              <p>There have been suggestions for a signature <code>arch:extract-text($archive as
                  xs:base64Binary)</code> returning all the entries. In the absence of maps in the
                return type, this does not make sense, since the entries are totally unlabelled, and
                to get anything meaningful, a parallel call on <code>arch:entries()</code> would be
                required.</p>
            </def>
          </gitem>
          <gitem>
            <label>Examples</label>
            <def>

              <p>Returning the text data for an entry in the archive stored in a file located at
                  <code>$uri</code>:</p>
              <eg xml:space="preserve">
arch:extract-text(file:read-binary($uri),'build.xml','UTF-8')
=&gt; stuff
     </eg>

            </def>
          </gitem>
        </glist>
      </div2>
    </div1>
    <div1 id="updating">
      <head>Updating entries in an archive</head>
      <p>There are two atomic actions available to change entries within an archive: complete
        deletion of an entry, or complete updating (overwriting) of that entry – the latter adds new
        entries when the given name does not already exist in the archive</p>
      <div2 id="fn.delete">
        <head>arch:delete</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns an archive with the given entries deleted.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signature</label>
            <def>
              <p><example role="signature">
                  <proto name="delete" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="xs:string*"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Returns an archive of the same format as <code>$archive</code> with all the entries
                named in <code>$entries</code> deleted.</p>
              <p>The relative order of the remaining entries within the archive is preserved.</p>
              <p>The uncompressed content, size and last-modified date of the remaining entries
                shall be the same as those for those entries before deletion. Compressed sizes may
                alter.</p>
              <p>Duplicate entries in <code>$entries</code> are ignored.</p>
              <p>If <code>$entries</code> is the empty sequence, the original archive shall be
                returned.</p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.unknownEntry"/> is raised if an entry requested for deletion
                does not exist in this archive.</p>
              <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified
                problem in reading the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Notes</label>
            <def>
              <p>Whilst the uncompressed entries remaining after deletion should of course be the
                same size and content as those before deletion, depending upon the (lossless)
                compression algorithm used, the compressed sizes and content might not be. In the
                absence of a special check, in these circumstances <code>$archive</code> may not be
                identical to <code>arch:delete($archive,())</code>. This needs discussion. </p>
            </def>
          </gitem>
          <gitem>
            <label>Examples</label>
            <def>

              <p>Deleting the entries of the archive stored in a file located at
                <code>$uri</code>:</p>
              <eg xml:space="preserve">
arch:entries(arch:delete(file:read-binary($uri),'lumley.jpg'))
=&gt; &lt;arch:entry size="2194" compressed-size="652" last-modified="2013-07-18T11:22:12"&gt;build.xml&lt;/arch:entry&gt;
   &lt;arch:entry size="10058" compressed-size="1381" last-modified="2013-08-06T13:14:08"&gt;tests/qt3/binary/binary.xml&lt;/arch:entry&gt;
     </eg>

            </def>
          </gitem>
        </glist>
      </div2>
      <div2 id="fn.update">
        <head>arch:update</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns an archive with each of the given entries in <code>$entries</code> updated
                to the corresponding values in the sequence <code>$new</code>. If an entry is not
                found, a new entry is added to the end of the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signatures</label>
            <def>
              <p><example role="signature">
                  <proto name="update" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="xs:string*"/>
                    <arg name="new" type="xs:base64Binary*"/>
                  </proto>
                </example><example role="signature">
                  <proto name="update" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="xs:string*"/>
                    <arg name="new" type="xs:base64Binary*"/>
                    <arg name="last-modified" type="xs:dateTime"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Returns an archive of the same format as <code diff="del">$archive</code><code
                  diff="add">$archive</code> with each of the given entries in <code>$entries</code>
                updated to the corresponding value in the sequence <code>$new</code>. If an entry is
                not found, a new entry for it is added to the end of the archive.</p>
              <p>The relative order of all the existing and replaced entries within the archive is
                preserved. New entries appear at the end of the archive in the order in which they
                were specified in the call.</p>
              <p>If specified, and the format supports it, the last-modified date for each of the
                updated entries will be set to <code>$last-modified</code>. In the absence of such a
                parameter, it is implementation-dependent whether last-modified information will be
                written on the updated entries. If such default last-modification is written, it
                should be comparable to the value of <code>fn:current-dateTime()</code> in an XSLT
                environment.</p>
              <p>The uncompressed content, size and last-modified date of the remaining entries
                shall be the same as those for those entries before deletion. Compressed sizes may
                alter.</p>
              <p>The compression methods of the updated entries shall be preserved.</p>
              <p>When duplicate names appear in the entry list, the value of the entry in the
                resulting archive will be that of the value of <code>$new</code> corresponding to
                the <emph>last</emph> matching entry name. </p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.entryDataMismatch"/> is raised if <code>count($entries) ne
                  count($new)</code>.</p>
              <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified
                problem in reading or creating the archive.</p>
            </def>
          </gitem>
        </glist>
      </div2>
    </div1>
    <div1 id="creating">
      <head>Creating an archive</head>
      <p diff="chg">New archives can be created in empty or filled states.</p>
      <div2 id="fn.create">
        <head>arch:create</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns a new archive with each of the given entries in <code>$entries</code> set
                to the corresponding values in the sequence <code>$new</code>.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signatures</label>
            <def>
              <p><example role="signature">
                  <proto name="create" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="entries" type="xs:string*"/>
                    <arg name="new" type="xs:base64Binary*"/>
                  </proto>
                </example><example role="signature">
                  <proto name="create" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="entries" type="xs:string*"/>
                    <arg name="new" type="xs:base64Binary*"/>
                    <arg name="options" type="element(arch:options)"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Returns an archive of format specified by <code>$options</code> with each of the
                given entries in <code>$entries</code> set to the corresponding value in the
                sequence <code>$new</code>.</p>
              <p>The relative order of new entries within the archive follows that of the input.</p>
              <p>Content provided for any entry considered to be a directory is ignored.</p>
              <p>When duplicate names appear in the entry list, the value of the entry in the
                resulting archive will be that of the value of <code>$new</code> corresponding to
                the <emph>last</emph> matching entry name. </p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.entryDataMismatch"/> is raised if <code>count($entries) ne
                  count($new)</code>.</p>
              <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified
                problem in reading or creating the archive.</p>
            </def>
          </gitem>
        </glist>
      </div2>
    </div1>
    <div1 id="extracting">
      <head>Creating and extracting complete archives<phrase diff="add"> from and to file
          systems</phrase></head>
      <div2 id="fn.from.files">
        <head>arch:from-files</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Collects all the binary file contents from <code>$files</code> and writes them into
                an new archive which is returned.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signature</label>
            <def>
              <p><example role="signature">
                  <proto name="from-files" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="files" type="xs:string*"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Collects all the binary file contents from <code>$files</code> and writes them into
                an new archive which is returned.</p>
              <p>All file content is collected in binary mode, with no attempt at any conversion or
                decoding.</p>
              <p>File and directory path names are normalized to use the solidus ('/') path
                separator.</p>
              <p>Directories are written as empty entries.</p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <!--<p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified problem
        in reading the archive.</p>-->
              <p>Error conditions from <bibref ref="expathfile"/> may be raised if there are
                problems on reading from the filesystem, most noteably:</p>
              <ul>
                <li><bibref ref="error.fileNotFound"/> is raised if any of the specified file paths
                  do not exist.</li>
                <!--<li><bibref ref="error.noParent"/> is raised if the parent directory of an entry
          does not exist. (This should not happen.)</li>
        <li><bibref ref="error.overwriteDirectory"/> is raised if an entry is being written
          on to an existing directory.</li>-->
                <li><bibref ref="error.genericFile"/> is raised if any other error occurs.</li>
              </ul>
            </def>
          </gitem>
          <gitem>
            <label>Notes</label>
            <def>
              <p>This function should be equivalent to the following XSLT function<phrase diff="del"
                  >, already described in <specref ref="example.zip.from"/></phrase>:</p>
              <eg xml:space="preserve">
&lt;xsl:function name="arch:from-files" as="xs:base64Binary"&gt;
    &lt;xsl:param name="files" as="xs:string*"/&gt;
    &lt;xsl:variable name="all" as="xs:string*"
      select="for $f in $files return 
                  if(file:is-dir($f)) 
                  then (for $f1 in file:list($f,true()) return concat($f,$f1)) 
                  else $f"/&gt;
    &lt;xsl:variable name="normalized.names" select="for $n in $all return replace($n,'\\','/')"/&gt;
    &lt;xsl:variable name="content" as="xs:base64Binary*"
      select="for $f in $normalized.names return 
                  if(file:is-dir($f)) 
                  then xs:base64Binary('') 
                  else file:read-binary($f)"/&gt;
    &lt;xsl:sequence select="arch:create($normalized.names,$content)"/&gt;
&lt;/xsl:function&gt;
</eg>
              <p>This function may be provided by an XSLT package (which will probably use functions
                from <bibref ref="expathfile"/>, and from which appropriate error conditions may be
                propagated, or caught within the package) or by a purpose-built extension function
                that may be able to support such an operation within a context of streaming
                processing.</p>
            </def>
          </gitem>
        </glist>
      </div2>
      <div2 id="fn.to.files">
        <head>arch:to-files</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Extracts all the entries from <code>$archive</code> and writes them into an
                equivalent tree of directories and files in the filesystem at the current
                directory.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signature</label>
            <def>
              <p><example role="signature">
                  <proto name="to-files" return-type="()" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Extracts all the entries from <code>$archive</code> and writes them into an
                equivalent tree of directories and files in the filesystem at the current
                directory.</p>
              <p>All entries are written in binary mode, with no attempt at any conversion or
                decoding.</p>
              <p>Entry names are considered as file paths, with '/' and '\' separators normalized to
                the path separator for the execution operating system.</p>
              <p>Necessary intermediate directories are created.</p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified
                problem in reading the archive.</p>
              <p>Error conditions from <bibref ref="expathfile"/> may be raised if there are
                problems on writing to the filesystem, most noteably:</p>
              <ul>
                <li><bibref ref="error.fileExists"/> is raised if the specified path, or any of its
                  parent directories, points to an existing file. </li>
                <li><bibref ref="error.noParent"/> is raised if the parent directory of an entry
                  does not exist. (This should not happen.)</li>
                <li><bibref ref="error.overwriteDirectory"/> is raised if an entry is being written
                  on to an existing directory.</li>
                <li><bibref ref="error.genericFile"/> is raised if any other error occurs.</li>
              </ul>
            </def>
          </gitem>
          <gitem>
            <label>Notes</label>
            <def>
              <p>This function should be equivalent to the following XSLT function<phrase diff="del"
                  >, already described in <specref ref="example.zip.to"/></phrase>:</p>
              <eg xml:space="preserve">
&lt;xsl:function name="arch:to-files"&gt;
    &lt;xsl:param name="archive" as="xs:base64Binary"/&gt;
    &lt;xsl:variable name="entries" select="arch:entries($archive)"/&gt;
    &lt;xsl:variable name="dirs" select="$entries[ends-with(.,'/')]"/&gt;
    &lt;xsl:variable name="required.dirs"
        select="distinct-values(for $r in ($entries except $dirs) return
                                    replace($r,'/[^/]+$','/'))[ends-with(.,'/')]"/&gt;
    &lt;xsl:sequence
        select="for $d in distinct-values(($required.dirs,$dirs)) return 
                    file:create-dir(replace($d,'/$',''))"/&gt;
    &lt;xsl:sequence
        select="for $f in ($entries except $dirs) return 
                    file:write-binary($f,arch:extract-binary($archive,$f))"/&gt;
&lt;/xsl:function&gt;
</eg>
              <p>This function may be provided by an XSLT package (which will probably use functions
                from <bibref ref="expathfile"/>, and from which appropriate error conditions may be
                propagated, or caught within the package) or by a purpose-built extension function
                that may be able to support such an operation within a context of streaming
                processing.</p>
            </def>
          </gitem>
        </glist>
      </div2>
    </div1>
    <div1 diff="add" id="convenience">
      <head>Convenience functions</head>
      <p>A small number of convenience functions are defined for common cases of content,
        specifically to ensure that 'empty' entries (empty binary data) are produced for empty
        sequences, to ensure coherence between members of the parallel entry name and entry content
        sequences.</p>
      <div2 id="fn.text">
        <head>arch:text</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Encodes a string into binary data using a given encoding, suitable for content data
                for an entry.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signatures</label>
            <def>
              <p><example role="signature">
                  <proto name="text" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="in" type="xs:string*"/>
                  </proto>
                </example><example role="signature">
                  <proto name="text" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="in" type="xs:string*"/>
                    <arg name="encoding" type="xs:string"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>The <code>$encoding</code> argument is the name of an encoding. The values for this
                attribute follow the same rules as for the <code>encoding</code> attribute in an XML
                declaration. The only values which every implementation is
                  <rfc2119>required</rfc2119> to recognize are <code>utf-8</code> and
                  <code>utf-16</code>.</p>
              <p>If <code>$encoding</code> is ommitted, <code>utf-8</code> encoding is assumed.</p>
              <p>If the value of <code>$in</code> is the empty sequence, the function returns an
                empty binary data. <emph>This is unlike <code>bin:encode-string()</code>, which will
                  return an empty sequence</emph>.</p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.unknownEncoding"/> is raised if <code>$encoding</code> is
                invalid or not supported by the implementation.</p>
              <p><bibref ref="error.encoding"/>is raised if there is an error or malformed input
                during encoding the string. Additional information about the error may be passed
                through suitable error reporting mechanisms – this is implementation-dependant.</p>
            </def>
          </gitem>
        </glist>
      </div2>
      <div2 id="fn.xml">
        <head>arch:xml</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Encodes the serialization of an XML tree into binary data using a given encoding,
                suitable for content data for an entry.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signatures</label>
            <def>
              <p><example role="signature">
                  <proto name="xml" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="args" type="item()*"/>
                  </proto>
                </example><example role="signature">
                  <proto name="xml" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="args" type="item()*"/>
                    <arg name="params" type="element(output:serialization-parameters)?"/>
                  </proto>
                </example><example role="signature">
                  <proto name="xml" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="args" type="item()*"/>
                    <arg name="params" type="element(output:serialization-parameters)?"/>
                    <arg name="encoding" type="xs:string"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>The single-argument version of this function has the same effect as the
                two-argument version called with <code>$params</code> set to an empty sequence. This in turn is
                the same as the effect of passing an <code>output:serialization-parameters</code>
                element with no child elements.</p>
              <p>The <code>$params</code> argument is used to identify a set of serialization
                parameters. These are supplied in the form of an
                  <code>output:serialization-parameters</code> element, having the format described
                in <a
                  href="http://www.w3.org/TR/xslt-xquery-serialization-30/#serparams-in-xdm-instance"
                  >Section 3.1 Setting Serialization Parameters by Means of a Data Model
                  Instance</a>.</p>
              <p>The <code>$encoding</code> argument is the name of an encoding. The values for this
                attribute follow the same rules as for the <code>encoding</code> attribute in an XML
                declaration. The only values which every implementation is
                  <rfc2119>required</rfc2119> to recognize are <code>utf-8</code> and
                  <code>utf-16</code>.</p>
              <p>If <code>$encoding</code> is ommitted, <code>utf-8</code> encoding is assumed.</p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.unknownEncoding"/> is raised if <code>$encoding</code> is
                invalid or not supported by the implementation.</p>
              <p><bibref ref="error.encoding"/>is raised if there is an error or malformed input
                during encoding the string. Additional information about the error may be passed
                through suitable error reporting mechanisms – this is implementation-dependant.</p>
            </def>
          </gitem>
          <gitem>
            <label>Notes</label>
            <def>
              <p>This function is equivalent to
                  <code>arch:text(fn:serialize($args,$params),$encoding)</code>.</p>
            </def>
          </gitem>
        </glist>
      </div2>
    </div1>
    <div1 id="maps">
      <head>Functions using XSLT3.0 map() type</head>
      <p>The map type (<code>map(xs:untypedAtomic,item()*)</code>) proposed for XSLT3.0 can increase
        the coherence of the functions in this module significantly, mainly by retaining the
        structured connection between the entry name and its properties and content. In addition the
        properties of the overall archive (and its defaults for new entries) can similarly be
        defined in a single map.</p>
      <p>This section defines optional parallel functions to those above using maps for arguments or
        results. In general these functions have separate names (e.g.
          <code>arch:entries-map()</code>) derived from a consistent suffix ('<code>-map</code>')
        attached to the standard, element-based form.</p>
      <note>
        <p><code>map:keys($map as map(*)) as xs:anyAtomicType*</code> returns the keys that are
          present in a map, in unpredictable order. This means that if order within an archive is
          important (either in extraction or updating) other mechanisms, such as the
            <kw>position</kw> property, are needed to track or set that order.</p>
      </note>
      <note>
        <p>It should be possible to implement all the functions in this section as user-defined
          XSLT3.0 functions using the library described above.</p>
      </note>
      <note>
        <p><emph>FOR DISCUSSION</emph>. In general when using maps for denoting the entries to be
          manipulated, the arguments could be considered to be a (possibly empty) sequence of maps
          that are treated as if concatentated. [THIS NEEDS THOUGHT ABOUT OVERWRITING/MERGING COMMON
          KEYS]. In this draft the arguments are single maps. </p>
      </note>
      <div2 diff="chg" id="using.maps">
        <head>Using map types to describe entries and options</head>

        <p>An archive is described as a map <code>name -&gt; properties</code>, where the properties
          of each entry themselves are represented as a further map. The 'content', i.e. the real
          data, of an archive entry is described by the <kw>content</kw> property of that map. Thus
          a set of archive entries has type <code>map(xs:string, map(xs:string,item()*))</code></p>

        <p>Support for similar approaches using other map representations, such as <bibref
            ref="jsoniq"/> objects may be implementation dependent.</p>
        <div3 id="archive.options.map">
          <head>Archive property maps</head>
          <p>The properties of an archive itself, as opposed to its entries, can be described or
            defined with a map with the following entries:</p>
          <table cellpadding="5" border="1">
            <thead>
              <tr>
                <th>Property</th>
                <th>Type</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><kw>format</kw></td>
                <td><code>xs:string</code></td>
                <td>The format of this archive</td>
              </tr>
              <tr>
                <td><kw>compression</kw></td>
                <td><code>xs:string</code></td>
                <td>The compression algorithm used for compressing the archive.</td>
              </tr>
            </tbody>
          </table>
          <note>
            <p>Using a reserved name within an overall map (such as <code>arch:options</code>) would
              allow the options/properties for an archive to be stored alongside the entries
              themselves.</p>
          </note>
        </div3>
        <div3 id="entry.structures.map">
          <head>Entry property maps</head>
          <p>Entries within the archive can be also be accessed or described by entries in a map
              (<code>map(xs:string,map(xs:string,item()*))</code>). In this case the map key gives
            the (path)name of the archive entry (e.g. <code>build/build-j.xml</code>) and the value
            is a map of the properties of that entry.</p>
          <p>The keys are described in the following table, and specific use is described under each
            of the functions:</p>
          <table cellpadding="5" border="1">
            <thead>
              <tr>
                <th>Property</th>
                <th>Type</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><kw>size</kw></td>
                <td><code>xs:integer</code></td>

                <td>The original file size of the entry</td>
              </tr>
              <tr>
                <td><kw>compressed-size</kw></td>
                <td><code>xs:integer</code></td>

                <td>The compressed file size of the entry, i.e. the number of bytes it occupies in
                  the archive</td>
              </tr>
              <tr>
                <td><kw>last-modified</kw></td>
                <td><code>xs:dateTime</code></td>

                <td>The date of last modification of this entry</td>
              </tr>
              <tr>
                <td><kw>compression-level</kw></td>
                <td><code>xs:string</code></td>

                <td>An indicator of the level of (lossless?) compression</td>
              </tr>
              <tr>
                <td><kw>content</kw></td>
                <td><code>xs:base64Binary</code> or <code>xs:string</code></td>

                <td>The value of the entry read from the archive. This will only be set from
                    <code>arch:entries-map()</code> if <code>$return-content</code> is requested in
                  the call. </td>
              </tr>
              <tr>
                <td><kw>encoding</kw></td>
                <td><code>xs:string</code></td>

                <td>The encoding to be used for converting textual items to or from a byte sequence.
                  The absence of such an entry implies binary content. The only values which every
                  implementation is <rfc2119>required</rfc2119> to recognize are <code>utf-8</code>
                  and <code>utf-16</code></td>
              </tr>
              <tr>
                <td><kw>position</kw></td>
                <td><code>xs:integer</code></td>

                <td>The position of the entry in the archive, starting at 1.</td>
              </tr>
            </tbody>
          </table>

        </div3>
      </div2>


      <div2 id="fn.options.map">
        <head>arch:options-map</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns a description of the type and properties of a given archive as a map. </p>
            </def>
          </gitem>
          <gitem>
            <label>Signature</label>
            <def>
              <p><example role="signature">
                  <proto diff="chg" name="options-map" return-type="map(xs:string,item()?)"
                    isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>The description is returned as a map <code>map(xs:string,item()?)</code> with
                entries describing the details. The following are currently supported:</p>
              <ulist>
                <item><kw diff="chg">format</kw>: format of this archive</item>
                <item><kw diff="chg">compression</kw>: the compression algorithm that was
                  used.</item>
              </ulist>
              <p>If the archive format supports a compression algorithm varying on a per-entry
                basis, and more than one algorithm has been used in the archive, <code>mixed</code>
                is returned for the <kw diff="chg">compression</kw> entry.</p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.archiveReadError"/> is raised if there is an unspecified problem
                in reading the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Examples</label>
            <def>

              <p>Finding the properties of the archive stored in a file located at
                <code>$uri</code>:</p>
              <eg diff="chg" xml:space="preserve">
arch:options-map(file:read-binary($uri))
=&gt; map {'format' :'zip', 'compression' : 'deflate'}
</eg>

            </def>
          </gitem>
        </glist>
      </div2>
      <div2 id="fn.entries.map">
        <head>arch:entries-map</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns the entry descriptors for all the entries found within the archive as a
                map, optionally each with their content.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signatures</label>
            <def>
              <p><example role="signature">
                  <proto diff="chg" name="entries-map"
                    return-type="map(xs:string,map(xs:string,item()*))" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                  </proto>
                </example><example role="signature">
                  <proto diff="chg" name="entries-map"
                    return-type="map(xs:string,map(xs:string,item()*))" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="return-content" type="xs:boolean"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Keys to the returned map are the entry (path) names.</p>
              <p>The value for each map entry is a map describing the properties of that entry. For
                more details of this structure see <specref ref="entry.structures.map"/>. The
                specific properties returned are:</p>
              <ulist diff="add">
                <item>
                  <kw>size</kw>
                </item>
                <item>
                  <kw>compressed-size</kw>
                </item>
                <item>
                  <kw>last-modified</kw>
                </item>
                <item>
                  <kw>position</kw>
                </item>
                <item>
                  <kw>content</kw>: this will be set only if <code>$return-content</code> is defined
                  and equals <code>true()</code>. The type will be <code>xs:base64Binary</code>.
                </item>
              </ulist>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.archiveReadError"/> is raised if there is an unspecified problem
                in reading the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Notes</label>
            <def>
              <p>As the returned order of keys from <code>map:keys()</code> is not defined and can
                be implementation-dependant, <phrase diff="del">there may be a need for a
                  simple</phrase><phrase diff="add"> the results of the</phrase> function
                    <code>arch<phrase diff="del">M</phrase>:entry-names(xs:base64Binary) as
                  xs:string*</code> can be used as a key sequence to iterate through this map, or a
                sort based on the <kw>position</kw> property.</p>
              <p>Using <code>$return-content</code> makes it possible to return a complete archive
                in a single call. Archive options can be added through a compound shown in the
                examples.</p>
            </def>
          </gitem>
          <gitem>
            <label>Examples</label>
            <def>

              <p>Finding the entries of the archive stored in a file located at
                <code>$uri</code>:</p>
              <eg xml:space="preserve">
arch:entries-map(file:read-binary($uri))
=&gt; map{ 
  "build.xml" : map{ "size" : 2194, "compressed-size" : 652, "last-modified" : "2013-07-18T11:22:12"},
  "lumley.jpg" : map{ "size" : 84983, "compressed-size" : 84872, "last-modified" : "2009-03-23T11:15:06"},
  "tests/qt3/binary/binary.xml" : map{ "size" : 10058, "compressed-size" : 1381, "last-modified" : "2013-08-06T13:14:08"}}
     </eg>
              <p>Counting the number of apparent XML files in the previous example:</p>
              <eg xml:space="preserve">
count(map:keys(arch:entries-map(file:read-binary($uri)))[ends-with(.,'.xml')])
=&gt; 2
     </eg>


              <p>Returning an archive complete with options:</p>
              <eg xml:space="preserve">
map:new((map:new('arch:options',arch:options-map($archive)),arch:entries-map($archive)))
=&gt; map{
  "arch:options" : map{ "format" : "ZIP", "compression" : "flat" },
  "build.xml" : map{ "size" : 2194, "compressed-size" : 652, "last-modified" : "2013-07-18T11:22:12"},
  "lumley.jpg" : map{ "size" : 84983, "compressed-size" : 84872, "last-modified" : "2009-03-23T11:15:06"},
  "tests/qt3/binary/binary.xml" : map{ "size" : 10058, "compressed-size" : 1381, "last-modified" : "2013-08-06T13:14:08"}}
     </eg>

            </def>
          </gitem>
        </glist>
      </div2>

      <div2 id="fn.extractmap">
        <head>arch:extract-map</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns a copy of <code>$entries</code> with the content entries set to binary or
                decoded string data for the appropriate entry in the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signature</label>
            <def>
              <p><example role="signature">
                  <proto name="extract-map" return-type="map(xs:string,map(xs:string,item()?))"
                    isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="map(xs:string,map(xs:string,item()?))"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Return a copy of <code>$entries</code> with the <kw>content</kw> property of each
                entry set to binary or decoded string data for the appropriate entry in the
                archive.</p>
              <p>The map entries in <code>$entries</code> define whether binary or decoded string
                data is to be returned. (For details of properties see <specref
                  ref="entry.structures.map"/>.) The only relevant property is:</p>
              <ulist>
                <item>
                  <kw>encoding</kw>: if this is set, then the entry will be decoded from binary to
                    <code>xs:string</code> according to the named encoding. If absent, then the type
                  will be <code>xs:base64Binary</code>. </item>
              </ulist>
              <p>The value for each map entry in the return is the original entry from
                  <code>$entries</code> plus an additional or replaced property:</p>
              <ulist>
                <item>
                  <kw>content</kw>: the type will be <code>xs:string</code> or
                    <code>xs:base64Binary</code> dependant upon the presence of the
                    <kw>encoding</kw> property.</item>
              </ulist>
              <p>The behaviour of this function is defined by equivalent XPath:</p>
              <eg xml:space="preserve"><![CDATA[
map:new(for $k in map:keys($entries) 
   return 
     let $a := $entries($k),
         $text := map:contains($a,'encoding'),
         $encoding := ($a('encoding'),'UTF-8')[1],
         $data := arch:extract-binary($archive,$k) // error if not found
     return 
         map:entry($k,
             map:new(($a,
               map:entry('content',if($text) bin:decode-string($data,$encoding) else $data)
               ))
       )
     ]]></eg>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.unknownEntry"/> is raised if an entry requested does not exist
                in this archive.</p>
              <p><bibref ref="error.decoding"/> is raised if there was an error in decoding an
                entry.</p>
              <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified
                problem in reading the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Notes</label>
            <def>
              <p>As the original <code>$entries</code> are returned in the result map, with content
                added, other information, such as <kw>position</kw> is retained. </p>
            </def>
          </gitem>
          <gitem>
            <label>Examples</label>
            <def>

              <p>To collect all the XML entries as XML:</p>
              <eg xml:space="preserve"><![CDATA[
let $archive := file:read-binary($uri)
    $entries := arch:entries-map($archive),
    $xml-names := map:keys($entries)[ends-with(.,'.xml')],
    $get := map:new($xml-names ! map:entry(.,map:entry('encoding','UTF-8'))),
    $content := arch:extract-map($archive,$get)
return
    $xml-names ! fn:parse-XML($content(.)('content'))
     ]]></eg>

            </def>
          </gitem>
        </glist>
      </div2>
      <div2 id="fn.extract.binary.map">
        <head>arch:extract-binary-map</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns the sequence of requested entries from the archive as binary data.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signature</label>
            <def>
              <p><example role="signature">
                  <proto name="extract-binary-map" return-type="xs:base64Binary*" isOp="no"
                    prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="map(xs:string,item()*)"/>
                  </proto>
                </example></p>
              <p diff="del"><example role="signature">
                  <proto name="extract-binary" return-type="xs:base64Binary*" isOp="no"
                    prefix="archM">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="xs:string*"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Returns as binary data each entry in the archive <code>$archive</code> that corresponds
                to <phrase diff="del">the entry name input, or</phrase>
                <code>map:keys($entries)</code>, in sequence.</p>
              <p diff="del">When <code>$entries</code> has type <code>xs:string*</code>, the entries
                  <rfc2119>must</rfc2119> be returned in the order corresponding to that of the
                entries requested in <code>$entries</code>, not in the order in which they may exist
                in the archive.</p>
              <p diff="del">When <code>$entries</code> has type <code>xs:string*</code>, multiple
                requests for the same entry will be honoured, with copies of the entry appearing in
                corresponding multiple locations in the output sequence .</p>
              <p diff="add">Any information in the values of each entry of <code>$entries</code> is
                ignored.</p>

            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.unknownEntry"/> is raised if an entry requested does not exist
                in this archive.</p>
              <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified
                problem in reading the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Notes</label>
            <def>
              <p>Collection of all the entries as binary data can also be accomplished using
                  <code>arch:entries-map($archive,true())</code> and collecting the
                  <code>'content'</code> entry from each of the returned maps.</p>
            </def>
          </gitem>
        </glist>
      </div2>
      <div2 id="fn.extract.text.map">
        <head>arch:extract-text-map</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns the sequence of requested entries from the archive as decoded string
                data.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signatures</label>
            <def>
              <p><example role="signature">
                  <proto name="extract-text-map" return-type="xs:string*" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="map(xs:string,map(xs:string,item()?))"/>
                  </proto>
                </example><example role="signature">
                  <proto name="extract-text-map" return-type="xs:string*" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="map(xs:string,map(xs:string,item()?))"/>
                    <arg name="encoding" type="xs:string"/>
                  </proto>
                </example></p>
              <p diff="del"><example role="signature">
                  <proto name="extract-text" return-type="xs:string*" isOp="no" prefix="archM">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="xs:string*"/>
                  </proto>
                </example><example role="signature">
                  <proto name="extract-text" return-type="xs:string*" isOp="no" prefix="archM">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="xs:string*"/>
                    <arg name="encoding" type="xs:string"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Returns as decoded string data each entry in the archive <code>$archive</code> that
                corresponds to <code>map:keys($entries)</code>, in sequence.</p>
              <p diff="del">When <code>$entries</code> has type <code>xs:string*</code>, the entries
                  <rfc2119>must</rfc2119> be returned in the order corresponding to that of the
                entries requested in <code>$entries</code>, not in the order in which they may exist
                in the archive.</p>
              <p diff="del">When <code>$entries</code> has type <code>xs:string*</code>, multiple
                requests for the same entry will be honoured, with copies of the entry appearing in
                corresponding multiple locations in the output sequence .</p>
              <p>If <code>$encoding</code> is specified, or the property <kw>encoding</kw> appears
                in the entry in <code>$entries</code>, the strings are decoded according to that
                encoding, otherwise UTF-8 encoding is assumed.</p>
              <p>The behaviour of this function is defined by equivalent XPath:</p>
              <eg diff="chg" xml:space="preserve"><![CDATA[
for $k in map:keys($entries) 
   return 
     let $a := $entries($k),
         $thisEncoding := ($a('encoding'),$encoding,'UTF-8')[1],
         $data := arch:extract-binary($archive,$k) // error if not found
     return 
         bin:decode-string($data,$thisEncoding)
     ]]></eg>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.unknownEntry"/> is raised if an entry requested does not exist
                in this archive.</p>
              <p><bibref ref="error.unknownEncoding"/> is raised if an encoding requested is unknown
                or unsupported.</p>
              <p><bibref ref="error.decoding"/> is raised if there was an error in decoding an
                entry.</p>
              <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified
                problem in reading the archive.</p>
            </def>
          </gitem>
          <gitem diff="del">
            <label>Notes</label>
            <def>
              <p>The signatures with <code>$entries instance of xs:string*</code> are equivalent to
                  <code>arch:extract-text()</code>.</p>
            </def>
          </gitem>
        </glist>
      </div2>
      <div2 id="fn.create.map">
        <head>arch:create-map</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns a new archive with each of the given entries named as a key in
                  <code>$entries</code> set to the corresponding value in
                  <code>$entries($key)('content')</code>.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signatures</label>
            <def>
              <p><example role="signature">
                  <proto name="create-map" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="entries" type="map(xs:string,map(xs:string,item()*))"/>
                  </proto>
                </example><example role="signature">
                  <proto name="create-map" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="entries" type="map(xs:string,map(xs:string,item()*))"/>
                    <arg name="options" type="map(xs:string,item()*)"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Returns an archive of format specified by <code>$options</code> with each of the
                given entries named as a key in <code>$entries</code> set to the corresponding value
                in <code>$entries($key)('content')</code>, and with other properties defined by
                  <code>$entries($key)(*)</code> or <code>$options</code>.</p>
              <p>The map <code>$options</code> can contain properties both for the archive itself,
                and defaults for each entry. Relevant properties for the archive (see also <specref
                  ref="archive.options.map"/>) are:</p>
              <ulist diff="add">
                <item>
                  <kw>format</kw>
                </item>
                <item>
                  <kw>compression</kw>
                </item>
              </ulist>
              <p diff="add">Relevant properties for entries (see also <specref ref="entry.structures.map"/>)
                are:</p>
              <ulist diff="add">
                <item>
                  <kw>compression-level</kw>
                </item>
                <item>
                  <kw>last-modified</kw>
                </item>
                <item>
                  <kw>position</kw>: position order for entries. These need not be contiguous, but
                  should not be duplicated. </item>
                <item>
                  <kw>encoding</kw>. If this is set, then the <kw>content</kw> entry will be encoded
                  from <code>xs:string</code> to binary according to the named encoding. If absent,
                  then <kw>content</kw> is assumed of type <code>xs:base64Binary</code>. The only
                  values which every implementation is <rfc2119>required</rfc2119> to recognize are
                    <code>utf-8</code> and <code>utf-16</code>.</item>
                <item>
                  <kw>content</kw>: the content to write, treated either as <code>xs:string</code>
                  or <code>xs:base64Binary</code>, dependent upon <kw>encoding</kw>.</item>
              </ulist>
              <p diff="add">The relative order of entries within the archive follows that of the
                  <kw>position</kw> property, if specified, followed by all those lacking such a
                property, in an implementation-dependant order. The specific ordering is equivalent
                to:</p>
              <eg diff="add" xml:space="preserve"><![CDATA[
<xsl:variable name="$keys" select="map:keys($entries)"/>
<xsl:variable name="positioned" as="xs:string*">
  <xsl:perform-sort select="$keys[map:contains($entries(.),'position']">
    <xsl:sort select="$entries(.)('position')"/>
  </xsl:perform-sort>
</xsl:variable>
<xsl:for-each select="$positioned, $keys[not(.=$positioned)]">
      .... process ....
</xsl:for-each>
     ]]></eg>
              <p>If <code>$options</code> is specified, the overall archive properties (and defaults
                for the entries) are set to those specified in the map.</p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified
                problem in creating the archive.</p>
              <p diff="add"><bibref ref="error.duplicatePosition"/> is raised if two or more entries request
                the same position in the archive.</p>
            </def>
          </gitem>

        </glist>
      </div2>
      <div2 id="fn.update.map">
        <head>arch:update-map</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns an archive with each of the given entries in the keys of
                  <code>$entries</code> updated to the corresponding values in the
                  <code>$entries($key)('content')</code> and with other properties defined by
                  <code>$entries($key)(*)</code>. If an entry is not found, a new entry is added to
                the end of the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signatures</label>
            <def>
              <p><example role="signature">
                  <proto name="update-map" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="map(xs:string,map(xs:string,item()*))"/>
                  </proto>
                </example><example role="signature">
                  <proto name="update-map" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="map(xs:string,map(xs:string,item()*))"/>
                    <arg name="default.options" type="map(xs:string,item()*)"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Returns an archive of the same format as <code>$archive</code> with each of the
                given entries in the keys of <code>$entries</code> updated to the corresponding
                values in the <code>$entries($key)('content')</code> and with other properties
                defined by <code>$entries($key)(*)</code> or <code>$default.options</code>. If an
                entry is not found, a new entry is added to the end of the archive. Relevant
                properties (see also <specref ref="entry.structures.map"/>) are:</p>
              <ulist diff="add">
                <item>
                  <kw>compression-level</kw>
                </item>
                <item>
                  <kw>last-modified</kw>
                </item>
                <item>
                  <kw>position</kw>: position order for new (as opposed to updated) entries. These
                  need not be contiguous, but should not be duplicated. </item>
                <item>
                  <kw>encoding</kw>. If this is set, then the <kw>content</kw>entry will be encoded
                  from <code>xs:string</code> to binary according to the named encoding. If absent,
                  then <kw>content</kw> is assumed of type <code>xs:base64Binary</code>. The only
                  values which every implementation is <rfc2119>required</rfc2119> to recognize are
                    <code>utf-8</code> and <code>utf-16</code>.</item>
                <item>
                  <kw>content</kw>: the content to write, treated either as <code>xs:string</code>
                  or <code>xs:base64Binary</code>, dependent upon <kw>encoding</kw>.</item>
              </ulist>
              <p>If <code>$options</code> is specified, values will be used for the default
                properties for each entry, which may be overloaded by the property map for each
                individual entry.</p>
              <p>The relative order of all the existing and replaced entries within the archive is
                preserved. New entries appear at the end of the archive:<phrase diff="add"> any which have a
                  <kw>position</kw> property specified, are ordered according to that property,
                followed by any others in an implementation-dependent order</phrase>.</p>
              <p>The uncompressed content, size and last-modified date of the remaining entries
                shall be the same as those for those entries before deletion. Compressed sizes may
                alter.</p>
              <p>The compression methods of the updated entries shall be preserved.</p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified
                problem in reading or creating the archive.</p>
              <p diff="add"><bibref ref="error.duplicatePosition"/> is raised if two or more entries request
                the same position in the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Notes</label>
            <def>
              <p>Using the <code>$default</code> map a common compression method, last-modification
                date and similar can be set for a set of entries, whose minimal map entries are
                  <code>map{"content":=$content}</code>
              </p>
            </def>
          </gitem>
        </glist>
      </div2>
      <div2 id="fn.delete.map">
        <head>arch:delete-map</head>
        <glist>
          <gitem>
            <label>Summary</label>
            <def>
              <p>Returns an archive with the given entries deleted.</p>
            </def>
          </gitem>
          <gitem>
            <label>Signature</label>
            <def>
              <p><example role="signature">
                  <proto name="delete-map" return-type="xs:base64Binary" isOp="no" prefix="arch">
                    <arg name="archive" type="xs:base64Binary"/>
                    <arg name="entries" type="map(xs:string,item()*)"/>
                  </proto>
                </example></p>
            </def>
          </gitem>
          <gitem>
            <label>Rules</label>
            <def>
              <p>Returns an archive of the same format as <code>$archive</code> with all the entries
                named in <phrase diff="del"><code>$entries</code> or <code>$entries!map:keys(.)</code></phrase><phrase diff="add"><code>map:keys($entries)</code></phrase> deleted.</p>
              <p>The relative order of the remaining entries within the archive is preserved.</p>
              <p>The uncompressed content, size and last-modified date of the remaining entries
                shall be the same as those for those entries before deletion. Compressed sizes may
                alter.</p>
              <p>If <code>$entries</code> is an empty map, the original archive shall be
                returned.</p>
              <p>Any information in the values of each entry of <code>$entries</code> is
                ignored.</p>
            </def>
          </gitem>
          <gitem>
            <label>Error Conditions</label>
            <def>
              <p><bibref ref="error.unknownEntry"/> is raised if an entry requested for deletion
                does not exist in this archive.</p>
              <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified
                problem in reading the archive.</p>
            </def>
          </gitem>
          <gitem>
            <label>Notes</label>
            <def>
              <p>Whilst the uncompressed entries remaining after deletion should of course be the
                same size and content as those before deletion, depending upon the (lossless)
                compression algorithm used, the compressed sizes and content might not be. In the
                absence of a special check, implied in the rules,<code>$archive</code> may not be
                identical to <code>arch:delete-map($archive,map:new())</code>.</p>
            </def>
          </gitem>
        </glist>
      </div2>
    </div1>


  </body>

  <back>
    <div1 id="references">
      <head>References</head>
      <blist>

        <bibl id="epub" key="EPUB">
          <loc href="http://www.idpf.org/epub/30/spec/epub30-overview.html">EPUB 3 Overview</loc>.
          International Digital Publishing Forum. Recommended Specification 11 October 2011.</bibl>
        <bibl id="expathfile" key="EXPath File">
          <loc href="http://expath.org/spec/file">File Module</loc>. Christian Grün and Matthias
          Brantner, editors. EXPath Candidate Module. 14 June 2012.</bibl>
        <bibl id="expathbinary" key="EXPath Binary">
          <loc href="http://expath.org/spec/binary">Binary Module</loc>. Jirka Kosek and John
          Lumley, editors. EXPath Module. 3 December 2013.</bibl>
        <bibl id="fo30" key="F&amp;O 3.0">
          <loc href="http://www.w3.org/TR/xpath-functions-30/">XPath and XQuery Functions and
            Operators 3.0</loc>. Michael Kay, editor. W3C Candidate Recommendation 21 May
          2013.</bibl>
        <bibl id="gzip" key="GZIP">
          <loc href="http://www.gzip.org/zlib/rfc-gzip.html">GZIP file format specification version
            4.3</loc>. L. Peter Deutsch, 1996.</bibl>
        <bibl id="jsoniq" key="JSONiq">
          <loc href="http://www.jsoniq.org/">JSONiq – The JSON Query Language</loc>. FLWOR
          Foundation. 2013.</bibl>
        <bibl id="xmlschema1.1" key="XML Schema 1.1 Part 2">
          <loc href="http://www.w3.org/TR/xmlschema11-2/">W3C XML Schema Definition Language (XSD)
            1.1 Part 2: Datatypes</loc>. David Peterson et al, editors.W3C Recommendation 5 April
          2012.</bibl>
        <bibl id="zip" key="ZIP">
          <loc href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">ZIP File Format
            Specification</loc>.PKWare, Version 6.3.3, 1 September 2012.</bibl>
      </blist>
    </div1>
    <div1 id="errors">
      <head>Summary of error conditions</head>
      <blist>
        <bibl id="error.archiveReadError" key="arch:read-error">There was an general error in
          reading the archive</bibl>
        <bibl id="error.unknownEntry" key="arch:unknown-entry">The specified entry does not exist in
          this archive.</bibl>
        <bibl id="error.entryDataMismatch" key="arch:entry-data-mismatch">The sequence of entry
          names is not the same length as the sequence of updated values.</bibl>
        <bibl id="error.unknownEncoding" key="arch:unknown-encoding">The specified encoding is not
          supported.</bibl>
        <bibl id="error.decoding" key="arch:decoding-error">Error in decoding a string.</bibl>
        <bibl diff="add" id="error.duplicatePosition" key="arch:duplicate-position">Two entries are
          requesting the same order position in the archive.</bibl>
      </blist>
      <p>Errors possibly generated by code executed from module <bibref ref="expathfile"/>:</p>
      <blist>
        <bibl id="error.fileNotFound" key="file:not-found">The specified path does not exist.</bibl>
        <bibl id="error.fileExists" key="file:exists">The specified path already exists.</bibl>
        <bibl id="error.noParent" key="file:no-dir">The specified path does not point to a
          directory.</bibl>
        <bibl id="error.overwriteDirectory" key="file:is-dir">The specified path points to a
          directory.</bibl>
        <bibl id="error.genericFile" key="file:io-error">A generic file system error
          occurred.</bibl>
      </blist>
    </div1>
  </back>
</spec>
