<?xml version="1.0" encoding="UTF-8"?>
<fos:functions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:ex="http://expath.org/ns/xmlspec"
   xmlns:fos="http://www.w3.org/xpath-functions/spec/namespace"
  xsi:schemaLocation="http://www.w3.org/xpath-functions/spec/namespace fos.xsd">
   <fos:function name="exists" prefix="file">
      <fos:signatures>
         <fos:proto name="exists" return-type="xs:boolean">
            <fos:arg type="xs:string" name="path"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Tests if the file or directory pointed by <code>$path</code> exists.</p>
      </fos:summary>
      <fos:rules>
         <p>Tests if the file or directory pointed by <code>$path</code> exists.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="is-dir" prefix="file">
      <fos:signatures>
         <fos:proto name="is-dir" return-type="xs:boolean">
            <fos:arg type="xs:string" name="path"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Tests if <code>$path</code> points to a directory. On UNIX-based systems the root and
            the volume roots are considered directories.</p>
      </fos:summary>
      <fos:rules>
         <p>Tests if <code>$path</code> points to a directory. On UNIX-based systems the root and
            the volume roots are considered directories.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="is-file" prefix="file">
      <fos:signatures>
         <fos:proto name="is-file" return-type="xs:boolean">
            <fos:arg type="xs:string" name="path"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Tests if <code>$path</code> points to a file.</p>
      </fos:summary>
      <fos:rules>
         <p>Tests if <code>$path</code> points to a file.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="last-modified" prefix="file">
      <fos:signatures>
         <fos:proto name="last-modified" return-type="xs:dateTime">
            <fos:arg type="xs:string" name="path"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Returns the last modification time of a file or directory.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the last modification time of a file or directory.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errNF"/> is raised if <code>$path</code> does not exist.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="size" prefix="file">
      <fos:signatures>
         <fos:proto name="size" return-type="xs:integer">
            <fos:arg type="xs:string" name="file"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Returns the byte size of a file, or the value <code>0</code> for directories.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the byte size of a file, or the value <code>0</code> for directories.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errNF"/> is raised if <code>$path</code> does not exist.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="append" prefix="file">
      <fos:signatures>
         <fos:proto name="append" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="item()*" name="items"/>
         </fos:proto>
         <fos:proto name="append" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="item()*" name="items"/>
            <fos:arg type="element(output:serialization-parameters)" name="params"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Appends a sequence of items to a file. If the file pointed by <code>$file</code> does
            not exist, a new file will be created.</p>
      </fos:summary>
      <fos:rules>
         <p>Appends a sequence of items to a file. If the file pointed by <code>$file</code> does
            not exist, a new file will be created.</p>
         <p>
            <code>$params</code> controls the way the <code>$items</code> items are serialized. The
            semantics of <code>$params</code> is the same as for the <code>fn:serialize</code>
            function in <bibref ref="fo30"/>. This consists of an
               <code>output:serialization-parameters</code> element whose format is defined in
               <bibref ref="ser30"/>. In contrast to <code>fn:serialize,</code> the encoding stage
            will not be skipped by this function.</p>
         <p>The function returns the empty sequence if the operation is successful.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errND"/> is raised if the parent directory of <code>$file</code> does
               not exist.</item>
            <item>
               <bibref ref="errID"/> is raised if <code>$file</code> points to a directory.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="append-binary" prefix="file">
      <fos:signatures>
         <fos:proto name="append-binary" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="xs:base64Binary" name="value"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Appends a Base64 item as binary to a file. If the file pointed by <code>$file</code>
            does not exist, a new file will be created.</p>
      </fos:summary>
      <fos:rules>
         <p>Appends a Base64 item as binary to a file. If the file pointed by <code>$file</code>
            does not exist, a new file will be created.</p>
         <p>The function returns the empty sequence if the operation is successful.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errND"/> is raised if the parent directory of <code>$file</code> does
               not exist.</item>
            <item>
               <bibref ref="errID"/> is raised if <code>$file</code> points to a directory.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="append-text" prefix="file">
      <fos:signatures>
         <fos:proto name="append-text" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="xs:string" name="value"/>
         </fos:proto>
         <fos:proto name="append-text" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="xs:string" name="value"/>
            <fos:arg type="xs:string" name="encoding"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Appends a string to a file. If the file pointed by <code>$file</code> does not exist, a
            new file will be created.</p>
      </fos:summary>
      <fos:rules>
         <p>Appends a string to a file. If the file pointed by <code>$file</code> does not exist, a
            new file will be created.</p>
         <p>The optional parameter <code>$encoding</code>, if not provided, is considered to be
               <code>UTF-8</code>.</p>
         <p>The function returns the empty sequence if the operation is successful.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errND"/> is raised if the parent directory of <code>$file</code> does
               not exist.</item>
            <item>
               <bibref ref="errID"/> is raised if <code>$file</code> points to a directory.</item>
            <item>
               <bibref ref="errUE"/> is raised if <code>$encoding</code> is invalid or not supported
               by the implementation.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="append-text-lines" prefix="file">
      <fos:signatures>
         <fos:proto name="append-text-lines" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="xs:string*" name="values"/>
         </fos:proto>
         <fos:proto name="append-text-lines" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="xs:string*" name="lines"/>
            <fos:arg type="xs:string" name="encoding"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Appends a sequence of strings to a file, each followed by the system-dependent newline
            character. If the file pointed by <code>$file</code> does not exist, a new file will be
            created.</p>
      </fos:summary>
      <fos:rules>
         <p>Appends a sequence of strings to a file, each followed by the system-dependent newline
            character. If the file pointed by <code>$file</code> does not exist, a new file will be
            created.</p>
         <p>The optional parameter <code>$encoding</code>, if not provided, is considered to be
               <code>UTF-8</code>.</p>
         <p>The function returns the empty sequence if the operation is successful.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errND"/> is raised if the parent directory of <code>$file</code> does
               not exist.</item>
            <item>
               <bibref ref="errID"/> is raised if <code>$file</code> points to a directory.</item>
            <item>
               <bibref ref="errUE"/> is raised if <code>$encoding</code> is invalid or not supported
               by the implementation.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="copy" prefix="file">
      <fos:signatures>
         <fos:proto name="copy" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="source"/>
            <fos:arg type="xs:string" name="target"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Copies a file or a directory given a source and a target path/URI.</p>
      </fos:summary>
      <fos:rules>
         <p>Copies a file or a directory given a source and a target path/URI. The following cases
            may occur if <code>$source</code> points to a file:</p>
         <ol type="a">
            <li> if <code>$target</code> does not exist, it will be created.</li>
            <li> if <code>$target</code> is a file, it will be overwritten.</li>
            <li> if <code>$target</code> is a directory, the file will be created in that directory
               with the name of the source file. If a file already exists, it will be
               overwritten.</li>
         </ol>
         <p>The following cases may occur if <code>$source</code> points to a directory:</p>
         <ol type="a">
            <li> if <code>$target</code> does not exist, it will be created as directory, and all
               files of the source directory are copied to this directory with their existing local
               names.</li>
            <li> if <code>$target</code> is a directory, the source directory with all its files
               will be copied into the target directory. If a file already exists, it will be
               overwritten.</li>
         </ol>
         <p>Other cases will raise one of the errors listed below.</p>
         <p>The function returns the empty sequence if the operation is successful. If an error
            occurs during the operation, no rollback to the original state will be possible </p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errNF"/> is raised if the <code>$source</code> path does not
               exist.</item>
            <item>
               <bibref ref="errE"/> is raised if <code>$source</code> points to a directory and
                  <code>$target</code> points to an existing file.</item>
            <item>
               <bibref ref="errND"/> is raised if the parent directory of <code>$source</code> does
               not exist.</item>
            <item>
               <bibref ref="errID"/> is raised if <code>$source</code> points to a file and
                  <code>$target</code> points to a directory, in which a subdirectory exists with
               the name of the source file.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="create-dir" prefix="file">
      <fos:signatures>
         <fos:proto name="create-dir" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="dir"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Creates a directory, or does nothing if the directory already exists. The operation will
            create all non-existing parent directories.</p>
      </fos:summary>
      <fos:rules>
         <p>Creates a directory, or does nothing if the directory already exists. The operation will
            create all non-existing parent directories.</p>
         <p>The function returns the empty sequence if the operation is successful.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errE"/> is raised if the specified path, or any of its parent
               directories, points to an existing file.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="create-temp-dir" prefix="file">
      <fos:signatures>
         <fos:proto name="create-temp-dir" return-type="xs:string">
            <fos:arg type="xs:string" name="prefix"/>
            <fos:arg type="xs:string" name="suffix"/>
         </fos:proto>
         <fos:proto name="create-temp-dir" return-type="xs:string">
            <fos:arg type="xs:string" name="prefix"/>
            <fos:arg type="xs:string" name="suffix"/>
            <fos:arg type="xs:string" name="dir"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Creates a temporary directory and all non-existing parent directories and returns the
            full path to the created directory.</p>
      </fos:summary>
      <fos:rules>
         <p>Creates a temporary directory and all non-existing parent directories and returns the
            full path to the created directory.</p>
         <p>The temporary directory will not be automatically deleted after query execution. It is
            guaranteed to not already exist when the function is called.</p>
         <p>If <code>$dir</code> is not given, the directory will be created inside the
            system-dependent default temporary-file directory.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errND"/> is raised if the specified directory does not exist or points
               to a file.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="create-temp-file" prefix="file">
      <fos:signatures>
         <fos:proto name="create-temp-file" return-type="xs:string">
            <fos:arg type="xs:string" name="prefix"/>
            <fos:arg type="xs:string" name="suffix"/>
         </fos:proto>
         <fos:proto name="create-temp-file" return-type="xs:string">
            <fos:arg type="xs:string" name="prefix"/>
            <fos:arg type="xs:string" name="suffix"/>
            <fos:arg type="xs:string" name="dir"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Creates a temporary file and all non-existing parent directories and returns the full
            path to the created file.</p>
      </fos:summary>
      <fos:rules>
         <p>Creates a temporary file and all non-existing parent directories and returns the full
            path to the created file.</p>
         <p>The temporary file will not be automatically deleted after query execution. It is
            guaranteed to not already exist when the function is called.</p>
         <p>If <code>$dir</code> is not given, the directory will be created inside the
            system-dependent default temporary-file directory.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errND"/> is raised if the specified does not exist or points to a
               file.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="delete" prefix="file">
      <fos:signatures>
         <fos:proto name="delete" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="path"/>
         </fos:proto>
         <fos:proto name="delete" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="path"/>
            <fos:arg type="xs:boolean" name="recursive"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Deletes a file or a directory from the file system.</p>
      </fos:summary>
      <fos:rules>
         <p>Deletes a file or a directory from the file system.</p>
         <p>If the optional parameter <code>$recursive</code> is set to <code>true()</code>,
            sub-directories will be deleted as well.</p>
         <p>The function returns the empty sequence if the operation is successful.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errNF"/> is raised if <code>$path</code> does not exist.</item>
            <item>
               <bibref ref="errID"/> is raised if <code>$file</code> points to a non-empty
               directory.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="list" prefix="file">
      <fos:signatures>
         <fos:proto name="list" return-type="xs:string*">
            <fos:arg type="xs:string" name="dir"/>
         </fos:proto>
         <fos:proto name="list" return-type="xs:string*">
            <fos:arg type="xs:string" name="dir"/>
            <fos:arg type="xs:boolean" name="recursive"/>
         </fos:proto>
         <fos:proto name="list" return-type="xs:string*">
            <fos:arg type="xs:string" name="dir"/>
            <fos:arg type="xs:boolean" name="recursive"/>
            <fos:arg type="xs:string" name="pattern"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Lists all files and directories in a given directory. The order of the items in the
            resulting sequence is not defined. The "." and ".." items are never returned. The
            returned paths are relative to the provided directory <code>$dir</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>Lists all files and directories in a given directory. The order of the items in the
            resulting sequence is not defined. The "." and ".." items are never returned. The
            returned paths are relative to the provided directory <code>$dir</code>.</p>
         <p>If the optional parameter <code>$recursive</code> is set to <code>true()</code>, all
            directories and files will be returned that are found while recursively traversing the
            given directory.</p>
         <p>The optional <code>$pattern</code> parameter defines a name pattern in the glob syntax.
            If this is provided, only the paths of the files and directories whose names are
            matching the pattern will be returned.</p>
         <p>An implementation must support at least the following glob syntax for the pattern: <ul>
               <li>
                  <code>*</code> for matching any number of unknown characters and</li>
               <li>
                  <code>?</code> for matching one unknown character.</li>
            </ul>
         </p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errND"/> is raised <code>$dir</code> does not point to an existing
               directory.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="move" prefix="file">
      <fos:signatures>
         <fos:proto name="move" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="source"/>
            <fos:arg type="xs:string" name="target"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Moves a file or a directory given a source and a target path/URI.</p>
      </fos:summary>
      <fos:rules>
         <p>Moves a file or a directory given a source and a target path/URI. The following cases
            may occur if <code>$source</code> points to a file:</p>
         <ol type="a">
            <li> if <code>$target</code> does not exist, it will be created.</li>
            <li> if <code>$target</code> is a file, it will be overwritten.</li>
            <li> if <code>$target</code> is a directory, the file will be created in that directory
               with the name of the source file. If a file already exists, it will be
               overwritten.</li>
         </ol>
         <p>The following cases may occur if <code>$source</code> points to a directory:</p>
         <ol type="a">
            <li> if <code>$target</code> does not exist, it will be created as directory, and all
               files of the source directory are moved to this directory with their existing local
               names.</li>
            <li> if <code>$target</code> is a directory, the source directory with all its files
               will be moved into the target directory. If a file already exists, it will be
               overwritten.</li>
         </ol>
         <p>Other cases will raise one of the errors listed below.</p>
         <p>The function returns the empty sequence if the operation is successful. If an error
            occurs during the operation, no rollback to the original state will be possible </p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errNF"/> is raised if the <code>$source</code> path does not
               exist.</item>
            <item>
               <bibref ref="errE"/> is raised if <code>$source</code> points to a directory and
                  <code>$target</code> points to an existing file.</item>
            <item>
               <bibref ref="errND"/> is raised if the parent directory of <code>$source</code> does
               not exist.</item>
            <item>
               <bibref ref="errID"/> is raised if <code>$source</code> points to a file and
                  <code>$target</code> points to a directory, in which a subdirectory exists with
               the name of the source file.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="read-binary" prefix="file">
      <fos:signatures>
         <fos:proto name="read-binary" return-type="xs:base64Binary">
            <fos:arg type="xs:string" name="file"/>
         </fos:proto>
         <fos:proto name="read-binary" return-type="xs:base64Binary">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="xs:integer" name="offset"/>
         </fos:proto>
         <fos:proto name="read-binary" return-type="xs:base64Binary">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="xs:integer" name="offset"/>
            <fos:arg type="xs:integer" name="length"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Returns the content of a file in its Base64 representation.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the content of a file in its Base64 representation.</p>
         <p>The optional parameters <code>$offset</code> and <code>$length</code> can be used to
            read chunks of a file.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errNF"/> is raised if <code>$file</code> does not exist.</item>
            <item>
               <bibref ref="errID"/> is raised if <code>$file</code> points to a directory.</item>
            <item>
               <bibref ref="errOOR"/> is raised if <code>$offset</code> or <code>$length</code> is
               negative, or if the chosen values would exceed the file bounds.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="read-text" prefix="file">
      <fos:signatures>
         <fos:proto name="read-text" return-type="xs:string">
            <fos:arg type="xs:string" name="file"/>
         </fos:proto>
         <fos:proto name="read-text" return-type="xs:string">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="xs:string" name="encoding"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Returns the content of a file in its string representation.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the content of a file in its string representation.</p>
         <p>The optional parameter <code>$encoding</code>, if not provided, is considered to be
               <code>UTF-8</code>.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errNF"/> is raised if <code>$file</code> does not exist.</item>
            <item>
               <bibref ref="errID"/> is raised if <code>$file</code> points to a directory.</item>
            <item>
               <bibref ref="errUE"/> is raised if <code>$encoding</code> is invalid or not supported
               by the implementation.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="read-text-lines" prefix="file">
      <fos:signatures>
         <fos:proto name="read-text-lines" return-type="xs:string*">
            <fos:arg type="xs:string" name="file"/>
         </fos:proto>
         <fos:proto name="read-text-lines" return-type="xs:string*">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="xs:string" name="encoding"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Returns the contents of a file as a sequence of strings, separated at newline
            boundaries.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the contents of a file as a sequence of strings, separated at newline
            boundaries.</p>
         <p>The optional parameter <code>$encoding</code>, if not provided, is considered to be
               <code>UTF-8</code>.</p>
         <p>The newline handling is the same as for the <code>fn:unparsed-text-lines</code> function
            in <bibref ref="fo30"/>.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errNF"/> is raised if <code>$file</code> does not exist.</item>
            <item>
               <bibref ref="errID"/> is raised if <code>$file</code> points to a directory.</item>
            <item>
               <bibref ref="errUE"/> is raised if <code>$encoding</code> is invalid or not supported
               by the implementation.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="write" prefix="file">
      <fos:signatures>
         <fos:proto name="write" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="item()*" name="items"/>
         </fos:proto>
         <fos:proto name="write" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="item()*" name="items"/>
            <fos:arg type="element(output:serialization-parameters)" name="params"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Writes a sequence of items to a file. If <code>$file</code> already exists, it will be
            overwritten; otherwise, it will be created.</p>
      </fos:summary>
      <fos:rules>
         <p>Writes a sequence of items to a file. If <code>$file</code> already exists, it will be
            overwritten; otherwise, it will be created.</p>
         <p>
            <code>$params</code> controls the way the <code>$items</code> items are serialized. The
            semantics of <code>$params</code> is the same as for the <code>fn:serialize</code>
            function in <bibref ref="fo30"/>. This consists of an
               <code>output:serialization-parameters</code> element whose format is defined in
               <bibref ref="ser30"/>. In contrast to fn:serialize, the encoding stage will not be
            skipped by this function.</p>
         <p>The function returns the empty sequence if the operation is successful.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errND"/> is raised if the parent directory of <code>$file</code> does
               not exist.</item>
            <item>
               <bibref ref="errID"/> is raised if <code>$file</code> points to a directory.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="write-binary" prefix="file">
      <fos:signatures>
         <fos:proto name="write-binary" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="xs:base64Binary" name="value"/>
         </fos:proto>
         <fos:proto name="write-binary" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="xs:base64Binary" name="value"/>
            <fos:arg type="xs:integer" name="offset"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Writes a Base64 item as binary to a file. If <code>$file</code> already exists, it will
            be overwritten; otherwise, it will be created.</p>
      </fos:summary>
      <fos:rules>
         <p>Writes a Base64 item as binary to a file. If <code>$file</code> already exists, it will
            be overwritten; otherwise, it will be created.</p>
         <p>If the optional parameter <code>$offset</code> is specified, data will be written to
            this file position. An existing file may be resized by that operation.</p>
         <p>The function returns the empty sequence if the operation is successful.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errND"/> is raised if the parent directory of <code>$file</code> does
               not exist.</item>
            <item>
               <bibref ref="errID"/> is raised if <code>$file</code> points to a directory.</item>
            <item>
               <bibref ref="errOOR"/> is raised if <code>$offset</code> is negative, or if it
               exceeds the current file size.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="write-text" prefix="file">
      <fos:signatures>
         <fos:proto name="write-text" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="xs:string" name="value"/>
         </fos:proto>
         <fos:proto name="write-text" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="xs:string" name="value"/>
            <fos:arg type="xs:string" name="encoding"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Writes a strings to a file. If <code>$file</code> already exists, it will be
            overwritten.</p>
      </fos:summary>
      <fos:rules>
         <p>Writes a strings to a file. If <code>$file</code> already exists, it will be
            overwritten.</p>
         <p>The optional parameter <code>$encoding</code>, if not provided, is considered to be
               <code>UTF-8</code>.</p>
         <p>The function returns the empty sequence if the operation is successful.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errND"/> is raised if the parent directory of <code>$file</code> does
               not exist.</item>
            <item>
               <bibref ref="errID"/> is raised if <code>$file</code> points to a directory.</item>
            <item>
               <bibref ref="errUE"/> is raised if <code>$encoding</code> is invalid or not supported
               by the implementation.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="write-text-lines" prefix="file">
      <fos:signatures>
         <fos:proto name="write-text-lines" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="xs:string*" name="values"/>
         </fos:proto>
         <fos:proto name="write-text-lines" return-type="empty-sequence()">
            <fos:arg type="xs:string" name="file"/>
            <fos:arg type="xs:string*" name="values"/>
            <fos:arg type="xs:string" name="encoding"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Writes a sequence of strings to a file, each followed by the system-dependent newline
            character. If <code>$file</code> already exists, it will be overwritten; otherwise, it
            will be created.</p>
      </fos:summary>
      <fos:rules>
         <p>Writes a sequence of strings to a file, each followed by the system-dependent newline
            character. If <code>$file</code> already exists, it will be overwritten; otherwise, it
            will be created.</p>
         <p>The optional parameter <code>$encoding</code>, if not provided, is considered to be
               <code>UTF-8</code>.</p>
         <p>The function returns the empty sequence if the operation is successful.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errND"/> is raised if the parent directory of <code>$file</code> does
               not exist.</item>
            <item>
               <bibref ref="errID"/> is raised if <code>$file</code> points to a directory.</item>
            <item>
               <bibref ref="errUE"/> is raised if <code>$encoding</code> is invalid or not supported
               by the implementation.</item>
            <item>
               <bibref ref="errIE"/> is raised if any other error occurs.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="name" prefix="file">
      <fos:signatures>
         <fos:proto name="name" return-type="xs:string">
            <fos:arg type="xs:string" name="path"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Returns the name of a file or directory.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the name of a file or directory.</p>
         <p>An empty string is returned if the path points to the root directory, or if it contains
            no directory separators.</p>
         <p>This function is ·deterministic· (no path existence check is made).</p>
      </fos:rules>
   </fos:function>
   <fos:function name="parent" prefix="file">
      <fos:signatures>
         <fos:proto name="parent" return-type="xs:string?">
            <fos:arg type="xs:string" name="path"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Transforms the given path into an absolute path, as specified by <loc
               href="#fn.resolve-path">file:resolve-path</loc>, and returns the parent
            directory.</p>
      </fos:summary>
      <fos:rules>
         <p>Transforms the given path into an absolute path, as specified by <loc
               href="#fn.resolve-path">file:resolve-path</loc>, and returns the parent
            directory.</p>
         <p>An empty sequence is returned if the path points to a root directory.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="path-to-native" prefix="file">
      <fos:signatures>
         <fos:proto name="path-to-native" return-type="xs:string">
            <fos:arg type="xs:string" name="path"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Transforms a URI, an absolute path, or relative path to a canonical, system-dependent
            path representation. A canonical path is both absolute and unique and thus contains no
            redirections such as references to parent directories or symbolic links.</p>
      </fos:summary>
      <fos:rules>
         <p>Transforms a URI, an absolute path, or relative path to a canonical, system-dependent
            path representation. A canonical path is both absolute and unique and thus contains no
            redirections such as references to parent directories or symbolic links.</p>
         <p>If the resulting path points to a directory, it will be suffixed with the
            system-specific directory separator.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
      <fos:errors>
         <ulist>
            <item>
               <bibref ref="errIE"/> is raised if an error occurs while trying to obtain the native
               path.</item>
         </ulist>
      </fos:errors>
   </fos:function>
   <fos:function name="path-to-uri" prefix="file">
      <fos:signatures>
         <fos:proto name="path-to-uri" return-type="xs:anyURI">
            <fos:arg type="xs:string" name="path"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Transforms a file system path into a URI with the <code>file://</code> scheme. If the
            path is relative, it is first resolved against the current working directory.</p>
      </fos:summary>
      <fos:rules>
         <p>Transforms a file system path into a URI with the <code>file://</code> scheme. If the
            path is relative, it is first resolved against the current working directory.</p>
         <p>This function is ·deterministic· (no path existence check is made).</p>
      </fos:rules>
   </fos:function>
   <fos:function name="resolve-path" prefix="file">
      <fos:signatures>
         <fos:proto name="resolve-path" return-type="xs:string">
            <fos:arg type="xs:string" name="path"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Transforms a relative path into an absolute operating system path by resolving it
            against the current working directory.</p>
      </fos:summary>
      <fos:rules>
         <p>Transforms a relative path into an absolute operating system path by resolving it
            against the current working directory.</p>
         <p>If the resulting path points to a directory, it will be suffixed with the
            system-specific directory separator.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="dir-separator" prefix="file">
      <fos:signatures>
         <fos:proto name="dir-separator" return-type="xs:string"/>
      </fos:signatures>
      <fos:summary>
         <p>Returns the value of the operating system-specific directory separator, which usually is
               <code>/</code> on UNIX-based systems and <code>\</code> on Windows systems.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the value of the operating system-specific directory separator, which usually is
               <code>/</code> on UNIX-based systems and <code>\</code> on Windows systems.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="line-separator" prefix="file">
      <fos:signatures>
         <fos:proto name="line-separator" return-type="xs:string"/>
      </fos:signatures>
      <fos:summary>
         <p>Returns the value of the operating system-specific line separator, which usually is
               <code>&amp;#10;</code> on UNIX-based systems, <code>&amp;#13;&amp;#10;</code> on
            Windows systems and <code>&amp;#13;</code> on Mac systems.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the value of the operating system-specific line separator, which usually is
               <code>&amp;#10;</code> on UNIX-based systems, <code>&amp;#13;&amp;#10;</code> on
            Windows systems and <code>&amp;#13;</code> on Mac systems.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="path-separator" prefix="file">
      <fos:signatures>
         <fos:proto name="path-separator" return-type="xs:string"/>
      </fos:signatures>
      <fos:summary>
         <p>Returns the value of the operating system-specific path separator, which usually is
               <code>:</code> on UNIX-based systems and <code>;</code> on Windows systems.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the value of the operating system-specific path separator, which usually is
               <code>:</code> on UNIX-based systems and <code>;</code> on Windows systems.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="temp-dir" prefix="file">
      <fos:signatures>
         <fos:proto name="temp-dir" return-type="xs:string"/>
      </fos:signatures>
      <fos:summary>
         <p>Returns the path to the default temporary-file directory of an operating system.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the path to the default temporary-file directory of an operating system.</p>
         <p>This function is ·nondeterministic·.</p>
      </fos:rules>
   </fos:function>
</fos:functions>
